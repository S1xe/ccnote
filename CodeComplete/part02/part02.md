#### chapter05

P76

- 设计是不确定的
- 设计是自然而然形成的

P80

- 最小的复杂度 
- 易于维护
- 松散耦合
- 可扩展性
- 可重用性
- 高扇入
- 低扇出
- 可移植性
- 精简性
- 层次性
- 标准技术

P85

程序中不应该有任何环形关系

P95

信息隐藏的障碍
- 信息过度分散
- 循坏依赖
- 把类内数据误认为全局数据
- 可以察觉的性能损耗

P97

"我该隐藏些什么？"

P105

应用模式的另一个潜在陷阱是"为了模式而模式"

P110

最有效的原则之一就是不要卡在单一的方法上.如果用UML画设计图不可行,那就直接用英语来写.写段简短的测试程序.尝试一种截然不同的方法.想出一种蛮力解决方案.用铅笔画出轮廓和草图来指导思想.如果这些方法都不行,那就先离开这个问题.可以先去散散步,或者想一想其他的事情,然后再回来重新面对这个问题.如果你尽了全力还没能去的突破,那么暂时不要去想它反而会比穷思苦想的效果要好

---

#### chapter06

P141

让阅读代码比编写代码更方便

P144

遵循Liskov替换原则

P157

**核对表:类的质量**

---

####　chapter07

P163

使用子程序的好处就是因为它避免了重复的代码，从而使程序更易于开发、调试、编档和维护等等。

P164

创建子程序的正当理由

- 降低复杂度
- 引入中间、易懂的抽象
- 避免代码重复
- 支持子类化（subclass）
- 隐藏顺序
- 隐藏指针操作
- 提高可移植性（隔离不可移植的部分）
- 简化复杂的布尔判断
- 改善性能
- 保证所有的子程序都很小

P166

一个很好而又小巧的子程序会有很多用。其一便是它们能提高其可读性，其二便是简单的操作常常会变成复杂操作。

P167

创建类的很多理由也是创建子程序的理由

- 隔离复杂度
- 隐藏实现细节
- 限制变化所带来的影响
- 隐藏全局数据
- 形成中央控制点
- 促成可重用的代码
- 达到特定的重构目的


`主要目的：降低心智负担，让程序易懂`

P168

可取的内聚性

- 功能的内聚性

`即子程序所执行的操作与其名字相符，如果它做了其他操作，那么就不够内聚，同时其命名也有问题`

不太理想的内聚性

- 顺序上的内聚性
- 通信上的内聚性
- 临时的内聚性

不可取的内聚性

- 过程上的内聚性
- 逻辑上的内聚性
- 巧合的内聚性

P171

好的子程序名字

- 描述子程序所做的所有事情
- 避免使用无意义的、模糊或表述不清的动词
- 不要仅通过数字来形成不同的子程序名字
- 根据需要确定子程序名字的长度（一般9-15个字符）
- 给函数命名时要对返回值有所描述
- 给过程起名时要使用预期强烈的动词加宾语的形式
- 准确适用对仗词
- 为常用操作确立命名规则 

P174

如何使用子程序参数

- 按照输入-修改-输出的顺序排列参数
- 考虑自己创建in和out关键字
    ```C++
    //C++示例
    #define IN
    #define OUT
    void InvertMatrix(
        IN Matrix originalMatrix,
        OUT Matrix &resultMatrix);

    //使用const关键字定义输入参数通常更为适宜
    ```
- 如果几个子程序都用了类似的参数，应该让这些参数的排列顺序保持一致
- 使用所有的参数（不使用则删去）
- 把状态或出错变量放最后
- 不要把子程序的参数用作工作变量
- 在接口中对参数的假定加以说明（比注释还要的方法，使用断言）
- 把子程序的参数个数限制在大约7个以内
- 考虑对参数采用某种输入、修改、输出的命名规则
- 为子程序传递用以维持其接口抽象的变量或对象
    ```
    一般来说，如果在调用子程序前出现过装配(set up)的代码，或者在调用子程序之后出现拆卸(take down)的代码，都是子程序设计不佳的表现
    ```
- 使用具名参数
- 确保实际参数与形式参数相匹配





---

