#### chapter05

P76

- 设计是不确定的
- 设计是自然而然形成的

P80

- 最小的复杂度 
- 易于维护
- 松散耦合
- 可扩展性
- 可重用性
- 高扇入
- 低扇出
- 可移植性
- 精简性
- 层次性
- 标准技术

P85

程序中不应该有任何环形关系

P95

信息隐藏的障碍
- 信息过度分散
- 循坏依赖
- 把类内数据误认为全局数据
- 可以察觉的性能损耗

P97

"我该隐藏些什么？"

P105

应用模式的另一个潜在陷阱是"为了模式而模式"

P110

最有效的原则之一就是不要卡在单一的方法上.如果用UML画设计图不可行,那就直接用英语来写.写段简短的测试程序.尝试一种截然不同的方法.想出一种蛮力解决方案.用铅笔画出轮廓和草图来指导思想.如果这些方法都不行,那就先离开这个问题.可以先去散散步,或者想一想其他的事情,然后再回来重新面对这个问题.如果你尽了全力还没能去的突破,那么暂时不要去想它反而会比穷思苦想的效果要好

---

#### chapter06

P141

让阅读代码比编写代码更方便

P144

遵循Liskov替换原则

P157

**核对表:类的质量**

---

####　chapter07

P163

使用子程序的好处就是因为它避免了重复的代码，从而使程序更易于开发、调试、编档和维护等等。

P164

创建子程序的正当理由

- 降低复杂度
- 引入中间、易懂的抽象
- 避免代码重复
- 支持子类化（subclass）
- 隐藏顺序
- 隐藏指针操作
- 提高可移植性（隔离不可移植的部分）
- 简化复杂的布尔判断
- 改善性能
- 保证所有的子程序都很小

P166

一个很好而又小巧的子程序会有很多用。其一便是它们能提高其可读性，其二便是简单的操作常常会变成复杂操作。

P167

创建类的很多理由也是创建子程序的理由

- 隔离复杂度
- 隐藏实现细节
- 限制变化所带来的影响
- 隐藏全局数据
- 形成中央控制点
- 促成可重用的代码
- 达到特定的重构目的


`主要目的：降低心智负担，让程序易懂`

P168

可取的内聚性

- 功能的内聚性

`即子程序所执行的操作与其名字相符，如果它做了其他操作，那么就不够内聚，同时其命名也有问题`

不太理想的内聚性

- 顺序上的内聚性
- 通信上的内聚性
- 临时的内聚性

不可取的内聚性

- 过程上的内聚性
- 逻辑上的内聚性
- 巧合的内聚性

P171

好的子程序名字

- 描述子程序所做的所有事情
- 避免使用无意义的、模糊或表述不清的动词
- 不要仅通过数字来形成不同的子程序名字
- 根据需要确定子程序名字的长度（一般9-15个字符）
- 给函数命名时要对返回值有所描述
- 给过程起名时要使用预期强烈的动词加宾语的形式
- 准确适用对仗词
- 为常用操作确立命名规则 

P174

如何使用子程序参数

- 按照输入-修改-输出的顺序排列参数
- 考虑自己创建in和out关键字
    ```C++
    //C++示例
    #define IN
    #define OUT
    void InvertMatrix(
        IN Matrix originalMatrix,
        OUT Matrix &resultMatrix);

    //使用const关键字定义输入参数通常更为适宜
    ```
- 如果几个子程序都用了类似的参数，应该让这些参数的排列顺序保持一致
- 使用所有的参数（不使用则删去）
- 把状态或出错变量放最后
- 不要把子程序的参数用作工作变量
- 在接口中对参数的假定加以说明（比注释还要的方法，使用断言）
- 把子程序的参数个数限制在大约7个以内
- 考虑对参数采用某种输入、修改、输出的命名规则
- 为子程序传递用以维持其接口抽象的变量或对象
    ```
    一般来说，如果在调用子程序前出现过装配(set up)的代码，或者在调用子程序之后出现拆卸(take down)的代码，都是子程序设计不佳的表现
    ```
- 使用具名参数
- 确保实际参数与形式参数相匹配

P184

尽可能少的使用宏定义

P185

**核对表:高质量的子程序**

---

#### chapter08

P188

三种处理进来垃圾的情况
- 检查所有来源于外部的数据的值
- 检查子程序所有输入参数的值
- 决定如何处理错误的输入数据

P190

断言可以用于在代码中说明各种嘉定,澄清各种不希望的情形.

P191

断言是用来检查永远不该发生的情况,而错误处理代码是用来检查不太可能经常发生的非正常情况.

断言是可执行的注解

P193

对于高健壮性的代码,应该先使用断言再处理错误

P195

错误处理技术
- 返回中立值
- 换用下一个正确的数据
- 返回与前一次相同的数据
- 换用最接近的合法值
- 把警告信息记录到日志文件中
- 返回一个错误码
- 调用错误处理子程序或对象
- 当错误发生时显示出错误消息
- 用最妥当的方式处理局部错误
- 关闭程序

P197

健壮性与正确性

- 正确性意味着永不返回不准确的结果,哪怕不返回结果也比返回不准确的结果好
- 健壮性则意味着要不断尝试采取某些措施,以保证软件可以持续地运转下去,哪怕有时做出一些不够准确的结果

P211

**核对表:防御式编程**

---

##### chapter09

P216

创建一个类的步骤

- 创建类的总体设计
- 创建类中的子程序
- 复审并测试整个类

P218

一些有效使用伪代码的指导原则

- 用类似英语的语句来精确描述特定的操作
- 避免使用目标编程语言中的语法元素
- 在本意(intent)的层面上编写伪代码
- 再一个足够低的层次上编写伪代码,一遍可以近乎自动地从它生成代码
- 还可把伪代码变成编程语言中的注释

P219

使用风格良好的伪代码的好处

- 伪代码使得评审更容易
- 伪代码支持反复迭代精化的思想
- 伪代码使变更更加容易
- 伪代码能使给代码作注释的工作量减到最少
- 伪代码比其他形式的设计文档更容易维护

P221

设计子程序

- 检查先决条件
- 定义子程序要解决的问题
- 为子程序命名
- 决定如何测试子程序
- 在标准库中搜寻可用的功能
- 考虑错误处理
- 考虑效率问题
- 研究算法和数据类型
- 编写伪代码 
- 考虑数据
- 检查伪代码
- 在伪代码中试验一些想法,留下最好的想法(迭代)



---

