#### chapter14

P348

必须有明确顺序的语句

- 设法组织代码，使依赖关系变得非常明显
- 使子程序名能凸显依赖关系
- 利用子程序参数明确显示依赖关系
- 用注释对不清晰的依赖关系进行说明
- 用断言或者错误处理代码来检查依赖关系

P353

**核对表:组织直线型代码**

---

#### chapter15

P355

写if语句的时候遵循下述指导原则

- 首先写正常代码路径;再处理不常见情况
- 确保对于等量的分支是正确的
- 把正常情况的处理放在if的后面而不是else的后面
- 让if子句后面跟随一个有意义的语句
- 考虑else子句
- 测试else子句的正确性
- 检查if和else是不是弄反了

P359

if-then-else语句串

- 利用布尔函数调用简化复杂的检测
- 把最常见的情况方最前面
- 确保所有的情况都考虑到了
- 若语言支持,则if-then-else替换成其他结构

P365

**核对表:使用条件语句**

---

#### chapter16

P375

处理好循环体

- 使用{}把循环中的语句括起来
- 避免空循环
- 把循环的内务操作要么放在循环的开始,要么放循环的末尾

    `循环内务操作(housekeeping)指的是i=i+1 或 j++ 这样的表达式,不是完成循环工作而是控制循环`

- 一个循环只做一件事

P382

使用循环变量

- 用整数和枚举类型表示数组和循环的边界
- 在嵌套循环中使用有意义的变量名来提高其可读性
- 使用有意义的名字来避免循环下表串话
- 把循环下表的作用域限制在本循环内

P385

循环应该多长
- 循环要尽可能地短,以便能够一目了然
- 把循环嵌套限制在3层以内
- 把长循环的内容移到子程序里
- 要让长循环格外清晰

P388

**核对表:循环**

---

#### chapter17

P396

使用递归的技巧

- 确认递归能够停止
- 使用安全计数器防止出现无穷递归
- 把递归限制在一个子程序内
- 留心栈空间
- 不用去递归计算阶乘或者斐波那契数列

P410

**核对表:不常见的控制结构**

---

#### chapter18

P412

两个问题
-  表中查询条目的问题

    从表里查询记录的方法列表

    - 直接访问
    - 索引访问
    - 阶梯访问
- 在表里存什么

P423

构造查询键值

- 复制信息从而能够直接使用键值
- 转换键值以使其能够直接使用
- 把键值转换提取成独立的子程序

P428

使用阶梯技术的时候需要注意

- 留心端点
- 考虑使用二分查找取代顺序查找
- 考虑使用索引访问来取代阶梯技术
- 把阶梯表查询操作提取成单独的子程序

P429

**核对:表驱动法**

---

#### chapter19

P435

编写肯定形式的布尔表达式

- 在if语句中，把判断条件从否定形式转换为肯定形式，并且互换if和else子句中的代码
- 使用狄摩根定理简化否定的布尔判断

P445

改善深层嵌套

- 通过重复检测条件中的某一部分来简化嵌套的if语句
- 用break块来简化嵌套if
    ```
    do{
        if(...)
            break;
    }while(false);
    ```
- 把嵌套if转换成一组if-then-else语句
- 把嵌套if转换成switch-case语句
- 把深层嵌套的代码抽取出来放进单独的子程序
- 使用一种更加面向对象的方法，对象和多态派分
- 重新设计深层嵌套的代码

P453

对减少嵌套层次的技术的总结

P454

结构化编程的组成部分

- 顺序 
- 选择
- 迭代

P458

- 度量复杂度
- 处理复杂度的度量结果
- 其他类型的复杂度

P459

**核对表:控制结构相关事宜**

---
