#### chapter20

P463

软件外在质量特性

- 正确性
- 可用性
- 效率
- 可靠性
- 完整性
- 适应性
- 准确性
- 健壮性

P464

软件内在质量特性

- 可维护性
- 灵活性
- 可移植性
- 可重用性
- 可读性
- 可测试性
- 可理解性

P472

一步到位的方法明显比两步走的方法划算

代码复查的成本效益要比测试高出好几倍

P476

**核对表:质量保证计划**

---

#### chapter21

P483

成功运用结对编程的关键

- 用编码规范来支持结对编程
- 不要让结对编程变成旁观
- 不要强迫在简单问题上使用结对编程
- 有规律地对结对人员和分配的工作任务进行轮换
- 鼓励双方跟上对方的步伐
- 确认两个人都能看到显示器
- 不要强迫程序员与自己关系紧张的人组对
- 避免新手组合
- 指定一个组长

P484

**核对表:有效的结对编程**

P490

详查中的自尊心

P491

**核对表:有效的详查**


---

#### chapter22

P504

开发者测试的局限性

- 倾向于干净测试
- 对覆盖率有国语乐观的估计
- 往往会忽略一些更复杂的测试覆盖率类型

P517

82原则

P518

错误的分类

- 结构方面的问题
- 数据
- 已实现的功能
- 构建
- 集成
- 功能需求
- 测试的定义或者执行
- 整个系统,软件架构
- 未归档

P519

错误数据给予的提示

- 大多数错误的影响范围是相当有限的
- 许多错误发生在构建的范畴之外
- 大多数构建期错误是编程人员的事物造成的
- 笔误(拼写错误)是一个常见的问题根源
- 研究程序员所犯错误原因时,错误理解设计这条会经常出现
- 大多数错误容易修正
- 总结所在组织中对错误的经验

P522

减少测试用例当中的错误量

- 检查工作
- 开发软件的时候就要计划好测试用例
- 保留测试用例
- 将单元测试纳入测试框架

P528

改善测试过程

- 有计划的测试
- 重新测试(回归测试)
- 自动化测试

P529

保留测试记录

- 缺陷的管理方面描述
- 问题的完整描述
- 复现错误所需要的步骤
- 绕过该问题的建议
- 相关的缺陷
- 问题的严重程度
- 缺陷更远
- 对编码缺陷的分类
- 修正错误所改变的类和子程序
- 缺陷影响的代码行数
- 查找该错误所花的小时数
- 修正错误所花费的小时数

P532

**核对表:测试用例**

---

#### chapter23

P538

可以从错误中获取的好处

- 理解正在编写的程序
- 明确你烦了哪种类型的错误
- 从代码阅读者的角度分析代码质量
- 审视自己解决问题的方法
- 审视自己修正缺陷的方法

P541

寻找缺陷的有效方法

1. 将错误状态稳定下来
2. 确定错误的来源  ——

    a. 收集产生缺陷的相关数据

    b. 分析所收集的数据,并构造对缺陷的假说

    c.确定怎样去证实或证伪这个假设,可以对程序进行测试或是通过检查代码

    d. 按照2(c)的方法对假设做出最终结论
3. 修补缺陷
4. 对所修补的地方进行测试
5. 查找是否还有类似的错误

P544

寻找缺陷的一些小建议

- 在构造假设时考虑所有的可用数据
- 提炼产生错误的测试用例
- 在自己的单元测试族中测试代码
- 利用可用的工具
- 采用多种不同的方法重现错误
- 用更多的数据生成更多假设
- 利用否定性测试用例的结果
- 对可能的假设尝试头脑风暴
- 把需要尝试的事情逐条列出
- 缩小嫌疑代码的范围
- 对之前出现过缺陷的类和子程序保持浸提
- 检查最近修改过的代码
- 扩展嫌疑代码的范围
- 增量式集成
- 检查常见缺陷
- 同他人讨论问题
- 抛开问题,休息一下

P550

修正缺陷

- 在动手之前先要理解问题
- 理解程序本身,而不仅仅是问题
- 严重对错误的分析
- 放松一下

    匆忙动手解决问题是所能做的最低效的事情之一

- 保存最初的源代码
- 治本,而不是治标
- 修改代码时也一定要有恰当的理由
- 一次只做一个改动
- 检查自己的改动
- 增加能暴露问题的单元测试
- 搜索类似的缺陷

P559

**核对表:关于调试的建议**

---

#### chapter24

P565

重构的理由

- 代码重复
- 冗长的子程序

    改善系统的方法之一就是提升其模块性——增加定义完善、命名准确得子程序，让它们各自集中力量做好一件事

- 循环过长或嵌套过深
- 内聚性太差得类
- 类的接口未能提供层次一致得抽象
- 拥有太多参数得参数列表
- 类得内部修改往往被局限于某个部分
- 变化导致对多个类的相同修改
- 对继承体系的同样修改
- case语句需要做相同的修改
- 同时使用的数据并未以类的方式进行组织
- 成员函数使用其他类的特征比使用自身类的特征还要多
- 过多使用基本数据类型
- 某个类无所事事
- 一系列传递流浪数据的子程序
- 中间人对象无事可做
- 某个类同其他类关系过于亲密
- 子程序命名不恰当
- 数据成员被设置为公用
- 某个派生类仅使用了基类的很少一部分成员函数
- 注释被用于解释难懂的代码
- 使用了全局变量
- 在子程序前调用了设置代码或在调用后使用了收尾代码
- 程序中的一些代码似乎是在将来的某个时候才会用到的

P570

**核对表:重构的理由**

---