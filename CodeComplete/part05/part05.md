#### chapter20

P463

软件外在质量特性

- 正确性
- 可用性
- 效率
- 可靠性
- 完整性
- 适应性
- 准确性
- 健壮性

P464

软件内在质量特性

- 可维护性
- 灵活性
- 可移植性
- 可重用性
- 可读性
- 可测试性
- 可理解性

P472

一步到位的方法明显比两步走的方法划算

代码复查的成本效益要比测试高出好几倍

P476

**核对表:质量保证计划**

---

#### chapter21

P483

成功运用结对编程的关键

- 用编码规范来支持结对编程
- 不要让结对编程变成旁观
- 不要强迫在简单问题上使用结对编程
- 有规律地对结对人员和分配的工作任务进行轮换
- 鼓励双方跟上对方的步伐
- 确认两个人都能看到显示器
- 不要强迫程序员与自己关系紧张的人组对
- 避免新手组合
- 指定一个组长

P484

**核对表:有效的结对编程**

P490

详查中的自尊心

P491

**核对表:有效的详查**


---

#### chapter22

P504

开发者测试的局限性

- 倾向于干净测试
- 对覆盖率有国语乐观的估计
- 往往会忽略一些更复杂的测试覆盖率类型

P517

82原则

P518

错误的分类

- 结构方面的问题
- 数据
- 已实现的功能
- 构建
- 集成
- 功能需求
- 测试的定义或者执行
- 整个系统,软件架构
- 未归档

P519

错误数据给予的提示

- 大多数错误的影响范围是相当有限的
- 许多错误发生在构建的范畴之外
- 大多数构建期错误是编程人员的事物造成的
- 笔误(拼写错误)是一个常见的问题根源
- 研究程序员所犯错误原因时,错误理解设计这条会经常出现
- 大多数错误容易修正
- 总结所在组织中对错误的经验

P522

减少测试用例当中的错误量

- 检查工作
- 开发软件的时候就要计划好测试用例
- 保留测试用例
- 将单元测试纳入测试框架

P528

改善测试过程

- 有计划的测试
- 重新测试(回归测试)
- 自动化测试

P529

保留测试记录

- 缺陷的管理方面描述
- 问题的完整描述
- 复现错误所需要的步骤
- 绕过该问题的建议
- 相关的缺陷
- 问题的严重程度
- 缺陷更远
- 对编码缺陷的分类
- 修正错误所改变的类和子程序
- 缺陷影响的代码行数
- 查找该错误所花的小时数
- 修正错误所花费的小时数

P532

**核对表:测试用例**

---

#### chapter23

P538

可以从错误中获取的好处

- 理解正在编写的程序
- 明确你烦了哪种类型的错误
- 从代码阅读者的角度分析代码质量
- 审视自己解决问题的方法
- 审视自己修正缺陷的方法

P541

寻找缺陷的有效方法

1. 将错误状态稳定下来
2. 确定错误的来源  ——

    a. 收集产生缺陷的相关数据

    b. 分析所收集的数据,并构造对缺陷的假说

    c.确定怎样去证实或证伪这个假设,可以对程序进行测试或是通过检查代码

    d. 按照2(c)的方法对假设做出最终结论
3. 修补缺陷
4. 对所修补的地方进行测试
5. 查找是否还有类似的错误

P544

寻找缺陷的一些小建议

- 在构造假设时考虑所有的可用数据
- 提炼产生错误的测试用例
- 在自己的单元测试族中测试代码
- 利用可用的工具
- 采用多种不同的方法重现错误
- 用更多的数据生成更多假设
- 利用否定性测试用例的结果
- 对可能的假设尝试头脑风暴
- 把需要尝试的事情逐条列出
- 缩小嫌疑代码的范围
- 对之前出现过缺陷的类和子程序保持浸提
- 检查最近修改过的代码
- 扩展嫌疑代码的范围
- 增量式集成
- 检查常见缺陷
- 同他人讨论问题
- 抛开问题,休息一下

P550

修正缺陷

- 在动手之前先要理解问题
- 理解程序本身,而不仅仅是问题
- 严重对错误的分析
- 放松一下

    匆忙动手解决问题是所能做的最低效的事情之一

- 保存最初的源代码
- 治本,而不是治标
- 修改代码时也一定要有恰当的理由
- 一次只做一个改动
- 检查自己的改动
- 增加能暴露问题的单元测试
- 搜索类似的缺陷

P559

**核对表:关于调试的建议**

---

#### chapter24

P565

重构的理由

- 代码重复
- 冗长的子程序

    改善系统的方法之一就是提升其模块性——增加定义完善、命名准确得子程序，让它们各自集中力量做好一件事

- 循环过长或嵌套过深
- 内聚性太差得类
- 类的接口未能提供层次一致得抽象
- 拥有太多参数得参数列表
- 类得内部修改往往被局限于某个部分
- 变化导致对多个类的相同修改
- 对继承体系的同样修改
- case语句需要做相同的修改
- 同时使用的数据并未以类的方式进行组织
- 成员函数使用其他类的特征比使用自身类的特征还要多
- 过多使用基本数据类型
- 某个类无所事事
- 一系列传递流浪数据的子程序
- 中间人对象无事可做
- 某个类同其他类关系过于亲密
- 子程序命名不恰当
- 数据成员被设置为公用
- 某个派生类仅使用了基类的很少一部分成员函数
- 注释被用于解释难懂的代码
- 使用了全局变量
- 在子程序前调用了设置代码或在调用后使用了收尾代码
- 程序中的一些代码似乎是在将来的某个时候才会用到的

P570

**核对表:重构的理由**

P571

特定的重构

- 数据级的重构
- 语句级的重构
- 子程序级重构
- 类实现的重构
- 类接口的重构
- 系统级重构

P577

**核对表:重构总结**

P582

重构策略

- 在增加子程序时进行重构
- 在添加类的时候进行重构
- 在修补缺陷的时候进行重构
- 关注易于出错的模块
- 关注高度复杂的模块
- 在维护环境下,改善你手中正在处理的代码
- 定义清楚干净代码和拙劣代码的边界,然后尝试把代码移过这条边界

P584

**核对表:安全的重构**

---

#### chapter25

P588

只是关注于代码的运行速度,工作不免顾此失彼

P589

从以下方面思考效率问题

- 程序需求
- 程序设计
- 类和子程序的设计
- 程序同操作系统的交互
- 代码编译
- 硬件
- 代码调整

P593

一些无稽之谈

- 在高级语言中,减少代码的行数就可以提升所生产的机器代码的运行速度或是减少其资源占用
- 特定运算可能比其他的快,代码规模也较小
- 应当随时随地进行优化
- 程序的运行速度同其正确性同等重要

P598

常见的低效率之源

- 输入/输出操作
- 分页
- 系统调用
- 解释型语言
- 错误

P607

**核对表:代码调整策略**

---

#### chapter26

逻辑

- 在知道答案后停止判断
- 按照出现频率来调整判断顺序
- 相似逻辑结构之间的性能比较
- 用查询表代替复杂表达式
- 使用惰性求值

P616

循环

- 将判断外提
- 合并
- 展开
- 尽可能减少在循环内部的工作
- 哨兵值
- 把最忙的循环放在最内层
- 削减强度

P624

数据变换

- 使用整型数而不是浮点数
- 数组维度尽可能少
- 尽可能减少数组引用
- 使用辅助索引

    - 字符串长度索引
    - 独立的平行的索引结构

- 利用缓存机制

P630

表达式

- 利用代数恒等式
- 削弱运算强度

    - 加法代替乘法
    - 乘法代替幂乘
    - 利用三角恒等式代换等价的三角函数
    - 用long或int代替longlong整数(注意使用机器字长的整数和非机器字长整数带来的差异)
    - 用定点数或整型数代替浮点数
    - 单精度数代替双精度数
    - 用位移操作代替整数乘以2或除以2

- 编译期优化
- 小心系统函数
- 使用正确的常量类型
- 预先算出结果
- 删除公共子表达式

P639

子程序

- 将子程序重写成内联

P640

用低级语言重写代码

`当程序遭遇性能瓶颈的时候,你应当用低级语言重写代码`

P642

**核对表:代码调整法方法**

---